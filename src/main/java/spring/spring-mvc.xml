<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <!--
    说明：前端控制器加载处理映射器、适配器、视图解析器等组件，如果不在spring-mvc.xml中配置，则会自动使用spring-webmvc-4.3.1.RELEASE.jar包中org\springframework.web.servlet中DispatcherSerlvet.properties配置文件中的默认配置。
    -->


    <!--启用spring的一些annotation -->
    <!--<context:annotation-config/>-->

    <!-- ****************配置Handler 开始*********************-->
    <bean id="queryController" name="/query.action" class="com.syshlang.smm.controller.QueryController"></bean>
    <bean id="queryHttpController" name="/httpquery.action" class="com.syshlang.smm.controller.QueryHttpController">
    </bean>
    <!--
    对于注解的Handler可以单个配置,实际开发中建议使用组件扫描
    可以扫描controller、service、...这里让扫描controller，指定controller的包
	 -->
     <!--<bean class="com.syshlang.smm.controller.QueryAnnotationController" />-->
    <context:component-scan base-package="com.syshlang.smm.controller"></context:component-scan>


    <!-- ****************配置Handler 结束*********************-->


    <!--  *********************配置处理器映射器 开始*************************************** -->
    <!--
        所有的适配器都实现了HandlerMapping接口
    -->
    <!--第一种方式：最简单的，一个class对应一个handler（非注解）
    将bean的name当作url来查找，需要在配置Handler时配置bean的name(就是url)，如上
    -->
    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
    </bean>
    <!--第二种方式 集中映射配置 （非注解）
     SimpleUrlHandlerMapping是BeanNameUrlHandlerMapping的增强版本，
     它可以将url和处理器的bean的id进行统一的映射配置
    -->
    <bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="mappings">
            <props>
                <prop key="/query0.action">queryController</prop>
                <prop key="/query1.action">queryController</prop>
                <prop key="/httpquery0.action">queryHttpController</prop>
                <prop key="/httpquery1.action">queryHttpController</prop>
                <!--<prop key="url地址">Controller的bean的id</prop>-->
            </props>
        </property>
    </bean>

    <!-- 第三种方式 注解映射器
    在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。

在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器
    -->
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"></bean>



    <!--
    结论：① 多个映射器可以并存；
         ② 一个bean可以对应多个url；
         ③HandlerMapping 无需配置，springmvc可以默认启动；
         ④使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）。
    -->

    <!-- ********************************配置处理器映射器  结束************************** -->

    <!--  *********************配置处理器适配器 开始*************************************** -->
    <!--
        所有的处理器适配器都实现HandlerAdapter接口
    -->
    <!--①配置处理器适配器 (非注解)
      public boolean supports(Object handler) {
        return handler instanceof Controller;
    }

      SimpleControllerHandlerAdapter中的support方法可以看出：
      编写的handler需要实现Controller接口
      public interface Controller {
        ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
    }
        由此，开发Handler时需要实现Controller接口才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter来执行
    -->
    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter">
    </bean>
    <!--
      ②HttpRequestHandlerAdapter 是http请求处理适配器， (非注解)
      所有实现了HttpRequestHandler接口的bean通过此适配器进行适配、执行
     public boolean supports(Object handler) {
        return handler instanceof HttpRequestHandler;
    }

    由HttpRequestHandlerAdapter中的support方法可以看出：
    编写的handler需要实现HttpRequestHandler接口
    public interface HttpRequestHandler {
    void handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws ServletException, IOException;
}
    -->
    <bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"></bean>

    <!--③注解适配器
    在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。

在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器。

    -->
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"></bean>
    <!--  *********************配置处理器适配器 结束*************************************** -->

    <!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置
	mvc:annotation-driven默认加载很多的参数绑定方法，
	比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter
	实际开发时使用mvc:annotation-driven
	 -->
    <!-- <mvc:annotation-driven></mvc:annotation-driven> -->


    <!--  *********************配置视图解析器 开始*************************************** -->
    <!--视图解析器
    解析jsp文件，默认使用jstl的标签
    classpatch下要有jstl的jar包
    -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"></bean>
    <!--  *********************配置视图解析器 结束*************************************** -->

    <bean id="log4jInitialization" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
        <property name="targetClass" value="org.springframework.util.Log4jConfigurer" />
        <property name="targetMethod" value="initLogging" />
        <property name="arguments">
            <list>
                <value>classpath:log4j.properties</value>
            </list>
        </property>
    </bean>

</beans>